"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ProxyDateContainer {
    constructor(side, start, end, backing) {
        this.side = side;
        this.backing = backing;
        this.start = start;
        this.end = end;
    }
}
exports.ProxyDateContainer = ProxyDateContainer;
function DateProxy(side, start, end, inst) {
    return function (target, propertyKey) {
        if (target.ModLoader === undefined) {
            target['ModLoader'] = {};
        }
        if (target.ModLoader.dateproxies === undefined) {
            target.ModLoader['dateproxies'] = new Map();
        }
        target.ModLoader.dateproxies.set(new ProxyDateContainer(side, start, end, inst), propertyKey);
    };
}
exports.DateProxy = DateProxy;
function setupDateProxy(instance, isClient, isServer) {
    let p = Object.getPrototypeOf(instance);
    let arr = [];
    if (p.hasOwnProperty('ModLoader')) {
        if (p.ModLoader.hasOwnProperty("hasBeenProcessed")) {
            return arr;
        }
        if (p.ModLoader.hasOwnProperty('dateproxies')) {
            p.ModLoader.dateproxies.forEach(function (value, key) {
                let date = new Date();
                console.log((date >= key.start) + " | " + key.start);
                console.log((date <= key.end) + " | " + key.end);
                if (isClient && key.side === 0 /* CLIENT */ && (date >= key.start && date <= key.end)) {
                    instance[value] = new key.backing();
                    arr.push(instance[value]);
                }
                else if (isServer && key.side === 1 /* SERVER */ && (date >= key.start && date <= key.end)) {
                    instance[value] = new key.backing();
                    arr.push(instance[value]);
                }
            });
        }
    }
    return arr;
}
exports.setupDateProxy = setupDateProxy;
//# sourceMappingURL=DateProxy.js.map